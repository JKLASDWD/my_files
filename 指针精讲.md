# 指针精讲

输出指针   %p格式控制符

***指针类型决定了指针进行解引用操作的时候，能够访问空间的大小**

一个字节八位二进制，两位十六进制

指针类型决定了指针进行自增自减运算时**所走过的步长大小**

int型，一次走4个字节

char型，一次走1个字节

double型，一次走8个字节

指针实际上指向的是一个内存块，自增自减是跳到下一个内存块

### 野指针

概念：指向的位置是不可知的（随机的，不正确的）

1.未初始化的指针

2.指针越界访问

3.指针指向的空间释放  malloc与free函数或  **局部变量在自定义函数结束后被释放**

记得初始化定义指针指向NULL

### 指针+-整数

指针的自增自减运算与指针之间的比大小



### 指针-指针

必须是相同类型的指针且指向同一块内存空间，指针之间的相减才有意义

返回的差值即为两个指针之间步长的差值（可为负）



**关于越界规定**

**标准规定：允许 指向数组元素的指针 与指向数组的最后一个元素 后面的那个内存位置 的指针 进行比较**

**但是 不允许 与指向第一个元素之前的那个内存位置的指针进行比较**



数组名在绝大部分情况下代表数组 首元素 的地址

例外：

**1.&数组名**   取出的是整个数组的地址

**2.sizeof(数组名)**    数组名表示的是整个数组   -sizeof(数组名)计算的是整个数组的大小



区别

**自增自减运算时走过的步长会不一样**



### 二级指针

​	指针变量在内存空间中的存储，用二级指针进行指向

例 int** ppa=&pa;

.....

可扩展到多级指针



与数据结构有关





指针数组与数组指针

指针数组，用于存放指针的数组*p[]

数组指针，指向数组的指针   (*p)[]

已经学过，不再过多赘述



**指针的字节大小在32位系统中，是4个字节**

**在64位系统中式8个字节**



www.Stackoverflow.com

www.segmentfault.com



**报错例**

​	char *pstr="hello world"

实际上是把字符串hello world 首字符的地址放到了pstr中

**[hello world是一个常量字符串，不能被修改]**

不能执行类似 *pstr="W" 类似的操作

最准确的写法： const char *pstr="hello world"



例2

char *p1="abc"

char *p2="abc"

实际上p1==p2

abc是一个常量字符串，系统在存储的时候，不会再开辟另一块内存空间再存储同样的字符串

p1和p2都指向abc这一块



例3

如何用  **数组指针** 存放 **指针数组**？

char *p1[5]      指针数组

**char * (*p2)[5] = &p1 数组指针(指向指针数组)    ?**

**int (*parr3[10])[5]   一个数组，有10个元素，每个元素指向的数组有5个元素**

**单独摘出 parr3[10]**

类型为 int(*)[5]，是一个数组指针

先和[]结合，再和*结合





使用例

*p2 取到的是 p1的数组名

(*p2)[i]



一般在二维数组中进行应用，数组指针才会体现出作用



数组传参问题

一维数组

int arr[]// **int arr[i] ?**//int *arr // 

指针数组

int *arr[i] // int **arr 



二维数组



int arr[3] [5] //int arr[] [5] 

只能省略行，不能省略列

传地址

int （*arr）[5]



### 函数指针

​	指向函数的指针

"%p" &main

或者 &p main

**在函数中 ，&函数名 和 函数名 都是 函数的地址**

如何存储函数的地址？

**函数返回类型 (*pa) (int,int,....) =函数名**

**要写明函数的参数类型**

使用： (*pa)(2,3) ————与函数名(2,3)并无区别

存放函数地址的一个指针

(*p)()

解引用然后输入参数

 练习：

**( * (void (* ) （））0 )  （）**



void(*)（）————函数指针类型

()强制类型转换

把0强制类型转换成 (void(*)()) 函数指针类型

0就是一个函数的地址

*0  ——调用0地址处的该函数

(*0) ()  再对这个函数进行进行调用



​    *  (    void(*)()   ） 0    

**void（*signal（int,void（ * ）（int）））（int）**



signal  函数

第一个参数是整型，第二个参数是函数指针类型

void (*)  (int)

表明signal的返回值 也是一个函数指针类型

signal是一个函数的声明，有两个参数

该函数指针指向的函数的参数是int，返回类型是void

signal函数的返回类型也是一个函数指针，该函数指向的函数的参数是int，返回类型是void 



typedef void(*pfun_t)(int);

将void(*)(int)  (函数指针类型) 命名为 pfun_t

类似于 typedef unsigned int uint;

于是上面的式子可以写成

**pfun_t signal(int,pfun_t);**

